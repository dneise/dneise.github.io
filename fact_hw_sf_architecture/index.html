<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Dominik Neise" />
  <title>Hardware &amp; Software Architecture of FACT</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Hardware &amp; Software Architecture of FACT</h1>
  <p class="author">
Dominik Neise
  </p>
  <p class="date">29.11.2020</p>
</div>
<div id="fact" class="slide section level1">
<h1>FACT</h1>
<ul>
<li>Chereckov Telescope</li>
<li>1440 SiPM based readout channels (36ch / readout board)</li>
<li>Sampled with 2 GS/sec (512ns on board buffer)</li>
<li><p>300 samples (12bits = 2 byte) per trigger</p></li>
<li>max. sustainable trigger rate <span class="math inline">≈200</span> Hz</li>
<li><span class="math inline">⇒</span> <span class="math inline">≈160</span> MB/sec</li>
<li>data transport via TCP/IP</li>
<li>DAQ board acts as simple TCP server: waits for client to connect on port 5000</li>
<li><p>Trigger threshold and DAQ per channel are independ</p></li>
</ul>
</div>
<div id="trigger" class="slide section level1">
<h1>Trigger</h1>
<ul>
<li>self triggered (typical trigger rate 60Hz, i.e. ontime $10^{-5})</li>
<li>9 neighboring channels form a &quot;trigger patch&quot;. (160 patches)</li>
<li>channel signal is summed (analog, i.e. in real time)</li>
<li>each trigger patch sum signal compared to its own threshold -&gt; 160 digital signals</li>
<li>camera trigger is simple hard wired OR out of 160.</li>
</ul>
</div>
<div id="readout" class="slide section level1">
<h1>Readout</h1>
<ul>
<li>DAQ board has 512ns (analog) buffer</li>
<li>Trigger decicision takes few 10ns of ns:
<ul>
<li>Trigger stops sampling</li>
<li>analog data is digitzed</li>
<li>copied into onboard mem</li>
<li>subsequently send to DAQ board client via TCP/IP</li>
</ul></li>
</ul>
</div>
<div id="daq-board-hardware" class="slide section level1">
<h1>DAQ board hardware</h1>
<ul>
<li>TCP/IP stack implemented WIZNET W5100 chip</li>
<li>control and on-board-mem in FPGA (Xilinx Spartan)</li>
<li>Each of the 40 boards has a fixed geographical IP: <code>10.0.crate_id.board_id</code></li>
<li>groups of 10 DAQ boards share one subnet and are routed by the same router.</li>
</ul>
</div>
<div id="hardware-summary" class="slide section level1">
<h1>Hardware Summary</h1>
<ul>
<li>TCP/IP down: 1.2 MB/sec</li>
<li>DAQ board is server (only 1 client accepted)</li>
</ul>
</div>
<div id="bumper" class="slide section level1">
<h1>Bumper</h1>
<p>...</p>
</div>
<div id="daq-software-eventbuilder-evb" class="slide section level1">
<h1>DAQ software / Eventbuilder (EVB)</h1>
<ul>
<li>EVB connects to 40 boards</li>
<li>retrieves individual board event data (21 kB)</li>
<li>merges them to camera event (840 kB)</li>
<li>dumps events to disk into custom compressed binary data format. (<code>fits.fz</code>)</li>
<li>a typical file contains data of 5 minutes, i.e. 20k events. (&quot;run&quot;)</li>
</ul>
</div>
<div id="daq-products" class="slide section level1">
<h1>DAQ products</h1>
<ul>
<li>&quot;data&quot; file per run: custrom compressed binary file containing timestamped camera events, with run number and run type</li>
<li>many &quot;aux&quot; files: std FITS files (binary tables)</li>
<li>one file per service, not per server. So there are files like:
<ul>
<li><code>20201129_FTM_CTRL_TRIGGER_RATES.fits</code></li>
<li><code>20201129_FTM_CTRL_TRIGGER_THRESHOLDS.fits</code></li>
<li><code>20201129_FTM_CTRL_STATE.fits</code></li>
</ul></li>
<li>one row per timestamp (new row only when content changes, in order to save space)</li>
</ul>
<h3 id="caveat">Caveat</h3>
<p>Services need not to have identical timestamps, so correlation plots can be awkward.</p>
</div>
<div id="ipc-in-fact" class="slide section level1">
<h1>IPC in FACT</h1>
<ul>
<li>all FACT low level software comunicates via <a href="https://dim.web.cern.ch/">DIM</a></li>
<li>EVB is controlled via DIM</li>
<li>EVB emits &quot;slow&quot; status data via DIM as well.</li>
<li>all the other hardware control programs are also controlled via DIM</li>
<li>almost all FACT programs run on the same node.</li>
</ul>
</div>
<div id="dim" class="slide section level1">
<h1>DIM</h1>
<ul>
<li><a href="https://dim.web.cern.ch/dim_intro.html" class="uri">https://dim.web.cern.ch/dim_intro.html</a></li>
</ul>
<div class="figure">
<img src="imgs/dim.gif" style="width:60.0%" />

</div>
</div>
<div id="rpc-in-fact" class="slide section level1">
<h1>RPC in FACT</h1>
<ul>
<li>all FACT low level programs are implemented as a state machine</li>
<li>all have these special services:
<ul>
<li>STATE</li>
<li>AVAILABLE_SERVICES</li>
<li>AVAILABLE_COMMANDS</li>
<li>MESSAGES (doubles as a home brew distributed log system)</li>
</ul></li>
<li>one special DIM client &quot;data logger&quot;, subscibes to all existing clients services and dumps the to disk.
<ul>
<li>special MESSAGE service is merged by timestamp and dumped into a <code>yyyymmdd.log</code> text file</li>
</ul></li>
</ul>
</div>
<div id="commands" class="slide section level1">
<h1>Commands</h1>
<ul>
<li>Commands are defined in the implementation of each program.</li>
<li>There is not interface definition language (IDL) in use in FACT.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    T::AddEvent(<span class="st">&quot;SET_DAC_VALUE&quot;</span>, <span class="st">&quot;I:2&quot;</span>, FAD::State::kConnecting, FAD::State::kConnected, FAD::State::kRunInProgress)
        (bind(&amp;StateMachineFAD::SetDac, <span class="kw">this</span>, placeholders::_1))
        (<span class="st">&quot;Set DAC numbers in range to value&quot;</span>
        <span class="st">&quot;|addr[short]:Address of register (-1 for all)&quot;</span>
        <span class="st">&quot;|val[short]:Value to be set&quot;</span>);

    T::AddEvent(<span class="st">&quot;CONFIGURE&quot;</span>, <span class="st">&quot;X:2;C&quot;</span>, FAD::State::kConnected, FAD::State::kConfigured, FAD::State::kRunInProgress)
        (bind(&amp;StateMachineFAD::StartConfigure, <span class="kw">this</span>, placeholders::_1))
        (<span class="st">&quot;Configure a new run. If the internla trigger is enabled this might even start a new run.&quot;</span>
         <span class="st">&quot;|time_max[s]:Maximum time before the run is closed in seconds (0: unlimited)&quot;</span>
         <span class="st">&quot;|num_max[int]:Maximum number of events before the run is closed in seconds (0: unlimited)&quot;</span>
         <span class="st">&quot;|run_type[string]:Run type which describes the runs&quot;</span>);

    T::AddEvent(<span class="st">&quot;RESET_CONFIGURE&quot;</span>, FAD::State::kConfiguring1, FAD::State::kConfiguring2, FAD::State::kConfigured)
        (bind(&amp;StateMachineFAD::ResetConfig, <span class="kw">this</span>))
        (<span class="st">&quot;If configuration failed and the fadctrl is waiting for something, use this to reset the state.&quot;</span>);</code></pre></div>
</div>
<div id="prompt" class="slide section level1">
<h1>Prompt</h1>
<ul>
<li>Each FACT program, can be started with our without an interactive cmd shell</li>
<li>Commands can be issued</li>
<li>Current state can be seen</li>
<li>No Services can be seen, unless a special command is implemented which prints them to stdout.</li>
</ul>
<div class="figure">
<img src="imgs/fadctrl_states_and_allowed_commands.png" />

</div>
</div>
<div id="guis" class="slide section level1">
<h1>GUIs</h1>
<p>We had QT4 based GUIs. One big tabbed GUI. One Tab per program. Each command was connected to some button or text field. Each service was displayed in some sensible way.</p>
<p>This was great in the lab. When integrating the channels .. and shining light into them, we could quickly use the GUI to figure out the if the pixel mapping was messed up. Or we could have, if the GUIs had existed at that point :D.</p>
<p>But this also made us rigid. We could only see things, which were forseen during GUI design. Plot something vs. time? Impossible. Plot something vs. DAC setting of neighboring pixel to detect strange cross talk? Impossible.</p>
<p>However the bug GUI and the prompts of the individual programs allowed us to start the telescope and see &quot;First Light&quot;.</p>
</div>
<div id="generic-command-client---aka-dimctrl" class="slide section level1">
<h1>Generic Command Client - aka <code>dimctrl</code></h1>
<p>Since all Dim servers, broadcast their commands, state and services a generic client can be implemented:</p>
<div class="figure">
<img src="imgs/dimctrl.png" style="width:80.0%" />

</div>
<ul>
<li>unfortunately, no stdout is redirected from the servers to this shell.</li>
</ul>
</div>
<div id="scripting" class="slide section level1">
<h1>Scripting</h1>
<h2 id="storytime--">Storytime :-)</h2>
<p>When <code>dimctrl</code> cam into existance, we quicky wanted scripting. So our lead dev brewed a quick an dirty script parser. Just a text file with legal DIM commands, plus very few control statements:</p>
<pre><code>FADCTRL/RESET_CONFIGURE
FTMCTRL/START_RUN data 1000 300  # take 1000 events in 300seconds .. stop whatever is reached first.
.w FADCTRL DONE 310              # wait for FADCTRL to be in state DONE, timeout after 310 seconds</code></pre>
<p>This scripting engine had: - no variables - no if, apart from waiting for a state - no loops</p>
<p>This came into life, after we started runs manually by clicking a &quot;Start Run&quot; button every 5 minutes for a few nights. So even if loops were missing, we could just copy and paste commands and now start one scripts for an hour .. do some repositioning .. and start the next script again.</p>
</div>
<div id="databases" class="slide section level1">
<h1>Databases</h1>
<h3 id="configuration-database">Configuration Database</h3>
<p>Each program needs a bit of configuration during startup. This was handled by INI style so called <code>.rc</code>-files in the beginning. Easy to change and play around.</p>
<p>After some time, all (well .. most of them) settings were stored in a Database. The programs read their configuration during startup from that DB.</p>
<p>The DBs web frontend takes care of storing a history of changes. In FACT having a small git-repo with <code>.rc</code>-files would have been easier and less error prone.</p>
<p>Needing the MySQL DB to run, in times before docker, was a liability.</p>
<ul>
<li>Run Database</li>
</ul>
<p>After DAQ is a single 5min run is done and the file is on disk a simple bash script runs periodically to list all the files on disk and put newly created files into a DB. This DB is a starting point of all kinds of downstream archiving and analysis book keeping. Where is a file right now? Is it already calibrated or even analyzed?</p>
</div>
<div id="feedbacksystems" class="slide section level1">
<h1>Feedbacksystems</h1>
<p>FACT needs a feedback system to keep the SiPM overvoltage stable. The overvoltage is a known function of temperature and current. The camera measures both (different services of different servers).</p>
<p>One program subscribes to the relevants services, and adjusts the applied SiPM voltage according to the most recent temperature and current measurements.</p>
<p>This took FACT about 2 years. It would not be wise to need very long for this.</p>
</div>
<div id="real-scripting" class="slide section level1">
<h1>Real Scripting</h1>
<p>So as I said before, the home brewed script interface had many problems.</p>
<p>So we wanted a real scripting language. Some proposed Python (via PyDIM) some proposed JS. JS won the scripting language wars in FACT.</p>
<p>What came then, was one monolithic script on top of the existing many DIM programs. The input to this script was a nighly schedule, which it would try to execute, while periodically interleaving either calibration runs, or other consistency checks.</p>
</div>
<div id="web-display" class="slide section level1">
<h1>Web Display</h1>
<p>Since working with real GUIs via remote X connections, like <code>ssh -X</code>, <code>VNC</code> or whatever is awkward and slow. We wanted to move to the web. FACTs status (i.e. the lates value of some selected interesting DIM services) is publicly visible on the web: - simple logger, subscribes to relevant DIM services and dumps current state into homebrew text files - webserver machine mounts that folder with text files - JS website periodically reads those text files and updates its display.</p>
</div>
<div id="web-control" class="slide section level1">
<h1>Web control</h1>
<p>The same website allows, after login, to issue a selected subset of commands. These commands are issued via a DIM server running on the web server host into the JS DIM script interpreter.</p>
</div>
<div id="summary" class="slide section level1">
<h1>Summary</h1>
<ul>
<li>low level programs can and are still controlled via their CLI interface</li>
<li>QT4 guis were completely abandoned, imho waste of time to program them.</li>
<li>Config DB in case of a single telescope, imho overkill.</li>
<li>Instead of DIM, nowadays maybe GPB via ZMQ &amp; then gRPC on top?</li>
<li>Think about synchronizing slow data to simplify correlation plots?</li>
</ul>
</div>
</body>
</html>
